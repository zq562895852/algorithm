/**
 * 背包问题，爬楼梯问题：
 *   动态规划，状态转移方程最重要
 *
 * 合并有序列表：
 *   双指针，三指针，快排就是左右双指针+递归
 * 公共最长前缀：
 *   递归求子问题的最长前缀，分而治之，归并排序，分解直到有一个元素
 *   找出最大和最小值，比较这两个字符串的公共前缀，同时也是所有字符串的公共前缀
 *
 *
 * 最长无重复子串：
 *   存储索引，当第一个出现存储到map表中，当下一次出现取出更新索引(取最大的那个值，有可能索引会小于之前的，所以取最大值)
 * 删除指定元素：
 *   存储索引count=0，如果和目标值不等  则 arr[count++] = arr[i]
 * 删除排序后的重复元素，使只出现一个：
 *   双指针同时走，如果不等 arr[i] = arr[j];i++;   j指针始终+1
 * 两个数和：
 *   存储一个哈希表，当目标值和当前值差出现在哈希表中时，并且不是同一个直接返回即可
 * 反转整数：
 *    暴力就是：取绝对值，字符串反转
 *    取余：now=0;    cur%10   now每次*10,加上cur的余数，cur每次除以10
 *
 * 找到一个字符在另一个字符中出现的位置
 *    暴力：直接使用api查找
 *    快慢指针，一个从零，另一个从要查找的字符的length位置开始，取substr(slow,fast) 和目标值比较，相等直接返回
 * 查找一个值在有序数组插入的位置：
 *    二分查找
 *
 *  查找字符串中最后一个单词的长度：去除空格，从尾部放两个索引，一个索引--，直到下一个值为空，两个索引相减
 *
 *
 */
